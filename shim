#!/bin/sh

### BEGIN INIT INFO
# Provides:          shim
# Required-Start:
# Required-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Shim to launch a supervisor.
# Description:       Shim to launch a supervisor.
### END INIT INFO


# The following variables are defined:

# In this script:
# MYHOME      the detected location of init.d scripts
# MYNAME      the name of this script as called
# SVCNAME     the name of the service
# SVCDEFNAME  the path name of the service definition
# LIVESVC    the path name of the live service
# LASTRESULT  the return code of the last command
# STARTWAIT   the number of seconds to wait for successful start

# In os-settings:
# PATH     the file path to be searched by this script
# SVCDEF   the location of all service definitions
# SVCDIR   the location of all active services

# In supervisor-settings:
# SVCCTRL   the command used to control the supervisor
# SVCSTATUS the command to return the status of the supervised daemon
# CMDSTART  the command to be issued to the supervisor for staring the daemon
# CMDSTOP   the command to be issued to the supervisor for stopping the daemon

# Change DEBUG to 1 instead of 0 to display values at runtime.
DEBUG=0
[ $DEBUG -eq 1 ] && echo "DEBUG mode is on."

# Define the result scratchpad
LASTRESULT=0

# Number of seconds to wait for supervisor to report back.
# If set to zero, the start of the service is left to the
# supervisor and is considered an "asynchronous" start
STARTWAIT=7

# Where do I live? (i.e. where is my init.d collection)
MYHOME=$( dirname $0 )
[ $DEBUG -eq 1 ] && echo "MYHOME: $MYHOME"

# What is my (script) name?
MYNAME=$( basename $0 )
[ $DEBUG -eq 1 ] && echo "MYNAME: $MYNAME"

# What is my (daemon) name?
SVCNAME=$MYNAME
[ $DEBUG -eq 1 ] && echo "SVCNAME: $SVCNAME"

# By default, the service definition name is the same as $MYNAME, but in
# some cases you may wish to have a different service definition.  When
# that happens, simply uncomment and change the line below.
#SVCNAME="unknown"



# load settings for distribution
# includes PATH
. $MYHOME/os-settings

# detect if the settings were not changed.
[ "$PATH" = "fail" ] && echo "Failed to load PATH setting." && exit 1
[ "$SVCDEF" = "fail" ] && echo "Failed to load service directory definition setting." && exit 1
[ "$SVCDIR" = "fail" ] && echo "Failed to load service directory location setting." && exit 1
[ $DEBUG -eq 1 ] && echo "PATH: $PATH"
[ $DEBUG -eq 1 ] && echo "SVCDEF: $SVCDEF"
[ $DEBUG -eq 1 ] && echo "SVCDIR: $SVCDIR"

# Where is the (live) supervision directory for the daemon?
LIVESVC=$SVCDIR/$SVCNAME
[ $DEBUG -eq 1 ] && echo "LIVESVC: $LIVESVC"

# What service definition should I use to control the daemon?
SVCDEFNAME=$SVCDEF/$SVCNAME
[ $DEBUG -eq 1 ] && echo "SVCDEFNAME: $SVCDEFNAME"


# load settings for the supervision environment
# includes SVCCTRL, CMDSTART, CMDSTOP
. $MYHOME/supervisor-settings

# detect if the settings were not changed.
[ "$SVCCTRL" = "fail" ] && echo "Failed to load service control setting." && exit 1
[ "$SVCSTATUS" = "fail" ] && echo "Failed to load service status setting." && exit 1
[ "$CMDSTOP" = "fail" ] && echo "Failed to service stop setting." && exit 1
[ "$CMDSTART" = "fail" ] && echo "Failed to load service start setting." && exit 1
[ $DEBUG -eq 1 ] && echo "SVCCTRL: $SVCCTRL"
[ $DEBUG -eq 1 ] && echo "SVCSTATUS: $SVCSTATUS"
[ $DEBUG -eq 1 ] && echo "CMDSTOP: $CMDSTOP"
[ $DEBUG -eq 1 ] && echo "CMDSTART: $CMDSTART"


# Pre-check that $LIVESVC exists, otherwise
# any supervisor command is guaranteed to fail.
if [ ! -d $LIVESVC ];
then
  echo "$MYNAME: WARNING: no live definition exists at $LIVESVC"
fi


# Process the request
case "$1" in
  start)
    # A service definition needs to exist.
    if [ ! -d $SVCDEF/$SVCNAME ];
    then
      echo "$MYNAME: cannot start service without a definition.  Aborting."
      exit 1
    else
      [ $DEBUG -eq 1 ] && echo "Service definition found at $SVCDEF/$SVCNAME."
    fi

    # A live instance of the service definition needs to exist.
    if [ ! -d $LIVESVC ];
    then
      echo "$MYNAME: cannot start service without a live instance.  Aborting."
      exit 1
    else
      [ $DEBUG -eq 1 ] && echo "Service live instance found at $LIVESVC."
    fi

    # A service scan link of the live instance needs to exist.
    if [ -L $SVCSCAN/$SVCNAME ];
    then
      [ $DEBUG -eq 1 ] && echo "$MYNAME: WARNING: service scan link already exists."
    else
      ln -s $LIVESVC $SVCSCAN/$SVCNAME
      LASTRESULT=$?
      [ $DEBUG -eq 1 ] && echo "$MYNAME: service scan link created."
    fi

    # After a successful link, start the daemon.
    if [ $LASTRESULT -eq 0 ];
    then
      # wait for a confirmation that a supervisor is running for the service
      # NOTE: runit provides feedback that requires we send output to /dev/null
      $SVCSTATUS $SVCNAME >/dev/null
      LASTRESULT=$?
      until [ $STARTWAIT -eq 0 -o $LASTRESULT -eq 0 ];
      do
        sleep 1 # pause before checking again
        $SVCSTATUS $SVCNAME >/dev/null
        LASTRESULT=$?
        STARTWAIT=`expr $STARTWAIT - 1`
      done

      #
      if [ $LASTRESULT -eq 0 -a $STARTWAIT -gt 0 ];
      then
        $SVCCTRL $CMDSTART $SVCNAME
        LASTRESULT=$?
      else
        # supervisor does not appear to be successful in launching.
        echo "$MYNAME: ERROR: supervisor was not successfully launched."
        exit 1
      fi

    fi

    exit $LASTRESULT
    ;;

  stop)
    # Ask the supervisor to stop the daemon.
    $SVCCTRL $CMDSTOP $SVCNAME
    LASTRESULT=$?

    # After a successful stop, remove the service link.
    if [ $LASTRESULT -eq 0 ];
    then
      rm $SVCSCAN/$SVCNAME
      LASTRESULT=$?
    fi
    exit $LASTRESULT
    ;;

  restart)
    # Ask the supervisor to stop, then start the daemon.
    $SVCCTRL $CMDSTOP $LIVESVC && $SVCCTRL $CMDSTART $LIVESVC
    LASTRESULT=$?
    exit $LASTRESULT
    ;;
  status)
    # Ask the supervisor about the status of the daemon.
    $SVCSTATUS $MYNAME
    LASTRESULT=$?
    exit $LASTRESULT
    ;;
  force-reload)
    # LSB 3.1 specifies this as a mandatory command, but
    # there is no consistent method for enforcing it with
    # supervision.  By default, the command will fail.
    # However, the next two lines of code can be replaced
    # with customized commands to obtain a reload for the daemon.
    echo "forced reload is not a supported operation."
    exit 1
    ;;
  *)
    # Provide a catch-all to explain what are valid commands.
    echo "Usage: $MYNAME {start|stop|restart|status}"
    exit 1
    ;;
esac

exit 0

